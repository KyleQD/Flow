import { NextRequest, NextResponse } from 'next/server'
import { authenticateApiRequest, checkAdminPermissions } from '@/lib/auth/api-auth'

// Helper function to get color based on priority and type
function getEventColor(type: string, priority: string = 'medium'): string {
  const priorityColors = {
    low: 'gray',
    medium: 'blue',
    high: 'orange',
    urgent: 'red'
  }
  
  const typeColors = {
    event: 'green',
    tour: 'purple',
    task: 'orange',
    meeting: 'blue',
    deadline: 'red',
    booking: 'yellow',
    payment: 'emerald',
    logistics: 'indigo'
  }
  
  // For urgent items, always use red regardless of type
  if (priority === 'urgent') return 'red'
  
  // For high priority, use orange/red variants
  if (priority === 'high') {
    if (type === 'deadline') return 'red'
    if (type === 'task') return 'orange'
    return 'orange'
  }
  
  // Default to type color for medium/low priority
  return typeColors[type as keyof typeof typeColors] || 'blue'
}

export async function GET(request: NextRequest) {
  try {
    console.log('[Admin Calendar API] GET request started')
    
    const authResult = await authenticateApiRequest(request)
    if (!authResult) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { user, supabase } = authResult

    // Check admin permissions
    const hasAdminAccess = await checkAdminPermissions(user)
    if (!hasAdminAccess) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })
    }

    const { searchParams } = new URL(request.url)
    const startDate = searchParams.get('startDate')
    const endDate = searchParams.get('endDate')
    const eventType = searchParams.get('type') // tour, event, task, meeting, deadline, booking, payment, logistics
    const status = searchParams.get('status') // upcoming, ongoing, completed, cancelled
    const priority = searchParams.get('priority') // low, medium, high, urgent

    // Calculate date range if not provided
    const defaultStartDate = startDate || new Date().toISOString().split('T')[0]
    const defaultEndDate = endDate || new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]

    const calendarEvents: any[] = []

    // 1. Fetch Events (using correct column names)
    try {
      let eventsQuery = supabase
        .from('events')
        .select(`
          id,
          name as title,
          description,
          event_date,
          event_time,
          doors_open,
          duration_minutes,
          status,
          capacity,
          tickets_sold,
          ticket_price,
          venue_name,
          venue_address,
          created_at,
          created_by
        `)
        .gte('event_date', defaultStartDate)
        .lte('event_date', defaultEndDate)

      if (eventType && eventType === 'event') {
        // No additional filter needed for events
      }

      if (status) {
        eventsQuery = eventsQuery.eq('status', status)
      }

      const { data: events, error: eventsError } = await eventsQuery

      if (eventsError) {
        console.error('[Admin Calendar API] Events query error:', eventsError)
      } else {
        events?.forEach((event: any) => {
          const startTime = event.event_time ? new Date(`${event.event_date}T${event.event_time}`) : new Date(event.event_date)
          const endTime = event.duration_minutes 
            ? new Date(startTime.getTime() + event.duration_minutes * 60000)
            : new Date(startTime.getTime() + 2 * 60 * 60000) // Default 2 hours

          const priority = event.ticket_price && event.ticket_price > 100 ? 'high' : 'medium'
          const color = getEventColor('event', priority)

          calendarEvents.push({
            id: `event-${event.id}`,
            title: event.title,
            type: 'event',
            start: startTime,
            end: endTime,
            color,
            description: event.description,
            location: event.venue_name ? `${event.venue_name}, ${event.venue_address || ''}` : null,
            status: event.status || 'upcoming',
            priority,
            attendees: event.tickets_sold ? [event.tickets_sold] : [],
            capacity: event.capacity,
            originalData: event
          })
        })
      }
    } catch (error) {
      console.error('[Admin Calendar API] Events fetch error:', error)
    }

    // 2. Fetch Tours (using correct column names)
    try {
      let toursQuery = supabase
        .from('tours')
        .select(`
          id,
          name as title,
          description,
          start_date,
          end_date,
          status,
          budget,
          expenses,
          revenue,
          created_at,
          created_by
        `)
        .gte('start_date', defaultStartDate)
        .lte('end_date', defaultEndDate)

      if (eventType && eventType === 'tour') {
        // No additional filter needed
      }

      if (status) {
        toursQuery = toursQuery.eq('status', status)
      }

      const { data: tours, error: toursError } = await toursQuery

      if (toursError) {
        console.error('[Admin Calendar API] Tours query error:', toursError)
      } else {
        tours?.forEach((tour: any) => {
          const priority = tour.budget && tour.budget > 100000 ? 'high' : 'medium'
          const color = getEventColor('tour', priority)

          calendarEvents.push({
            id: `tour-${tour.id}`,
            title: tour.title,
            type: 'tour',
            start: new Date(tour.start_date),
            end: new Date(tour.end_date),
            color,
            description: tour.description,
            status: tour.status || 'upcoming',
            priority,
            originalData: tour
          })
        })
      }
    } catch (error) {
      console.error('[Admin Calendar API] Tours fetch error:', error)
    }

    // 3. Fetch Tasks (from tasks table)
    try {
      let tasksQuery = supabase
        .from('tasks')
        .select(`
          id,
          title,
          description,
          status,
          priority,
          due_date,
          created_at,
          created_by
        `)
        .gte('due_date', defaultStartDate)
        .lte('due_date', defaultEndDate)

      if (eventType && eventType === 'task') {
        // No additional filter needed
      }

      if (status) {
        tasksQuery = tasksQuery.eq('status', status)
      }

      if (priority) {
        tasksQuery = tasksQuery.eq('priority', priority)
      }

      const { data: tasks, error: tasksError } = await tasksQuery

      if (tasksError) {
        console.error('[Admin Calendar API] Tasks query error:', tasksError)
      } else {
        tasks?.forEach((task: any) => {
          const color = getEventColor('task', task.priority)

          calendarEvents.push({
            id: `task-${task.id}`,
            title: task.title,
            type: 'task',
            start: new Date(task.due_date),
            end: new Date(task.due_date),
            color,
            description: task.description,
            status: task.status || 'upcoming',
            priority: task.priority || 'medium',
            originalData: task
          })
        })
      }
    } catch (error) {
      console.error('[Admin Calendar API] Tasks fetch error:', error)
    }

    // 4. Fetch Bookings (simplified query without joins)
    try {
      let bookingsQuery = supabase
        .from('bookings')
        .select(`
          id,
          event_id,
          status,
          ticket_quantity,
          total_price,
          created_at
        `)
        .gte('created_at', defaultStartDate)
        .lte('created_at', defaultEndDate)

      if (eventType && eventType === 'booking') {
        // No additional filter needed
      }

      if (status) {
        bookingsQuery = bookingsQuery.eq('status', status)
      }

      const { data: bookings, error: bookingsError } = await bookingsQuery

      if (bookingsError) {
        console.error('[Admin Calendar API] Bookings query error:', bookingsError)
      } else {
        bookings?.forEach((booking: any) => {
          const priority = booking.total_price && booking.total_price > 1000 ? 'high' : 'medium'
          const color = getEventColor('booking', priority)

          calendarEvents.push({
            id: `booking-${booking.id}`,
            title: `Booking #${booking.id.slice(0, 8)}`,
            type: 'booking',
            start: new Date(booking.created_at),
            end: new Date(booking.created_at),
            color,
            description: `${booking.ticket_quantity} tickets - $${booking.total_price}`,
            status: booking.status || 'pending',
            priority,
            originalData: booking
          })
        })
      }
    } catch (error) {
      console.error('[Admin Calendar API] Bookings fetch error:', error)
    }

    // 5. Fetch Payments (from event_expenses)
    try {
      let paymentsQuery = supabase
        .from('event_expenses')
        .select(`
          id,
          event_id,
          category,
          description,
          amount,
          expense_date,
          status,
          created_at
        `)
        .gte('expense_date', defaultStartDate)
        .lte('expense_date', defaultEndDate)

      if (eventType && eventType === 'payment') {
        // No additional filter needed
      }

      if (status) {
        paymentsQuery = paymentsQuery.eq('status', status)
      }

      const { data: payments, error: paymentsError } = await paymentsQuery

      if (paymentsError) {
        console.error('[Admin Calendar API] Payments query error:', paymentsError)
      } else {
        payments?.forEach((payment: any) => {
          const priority = payment.amount && payment.amount > 5000 ? 'high' : 'medium'
          const color = getEventColor('payment', priority)

          calendarEvents.push({
            id: `payment-${payment.id}`,
            title: `Payment: ${payment.description}`,
            type: 'payment',
            start: new Date(payment.expense_date),
            end: new Date(payment.expense_date),
            color,
            description: `${payment.category} - $${payment.amount}`,
            status: payment.status || 'pending',
            priority,
            originalData: payment
          })
        })
      }
    } catch (error) {
      console.error('[Admin Calendar API] Payments fetch error:', error)
    }

    // 6. Fetch Logistics (from staff_schedules - simplified)
    try {
      let logisticsQuery = supabase
        .from('staff_schedules')
        .select(`
          id,
          staff_id,
          event_id,
          shift_start,
          shift_end,
          role,
          status,
          notes,
          created_at
        `)
        .gte('shift_start', defaultStartDate)
        .lte('shift_end', defaultEndDate)

      if (eventType && eventType === 'logistics') {
        // No additional filter needed
      }

      if (status) {
        logisticsQuery = logisticsQuery.eq('status', status)
      }

      const { data: logistics, error: logisticsError } = await logisticsQuery

      if (logisticsError) {
        console.error('[Admin Calendar API] Logistics query error:', logisticsError)
      } else {
        logistics?.forEach((logistic: any) => {
          const color = getEventColor('logistics', 'medium')

          calendarEvents.push({
            id: `logistic-${logistic.id}`,
            title: `${logistic.role} Shift`,
            type: 'logistics',
            start: new Date(logistic.shift_start),
            end: new Date(logistic.shift_end),
            color,
            description: logistic.notes,
            status: logistic.status || 'scheduled',
            priority: 'medium',
            originalData: logistic
          })
        })
      }
    } catch (error) {
      console.error('[Admin Calendar API] Logistics fetch error:', error)
    }

    // 7. Fetch Deadlines (from event_notes - simplified)
    try {
      let deadlinesQuery = supabase
        .from('event_notes')
        .select(`
          id,
          event_id,
          note_type,
          title,
          content,
          priority,
          created_at
        `)
        .eq('note_type', 'urgent')
        .gte('created_at', defaultStartDate)
        .lte('created_at', defaultEndDate)

      if (eventType && eventType === 'deadline') {
        // No additional filter needed
      }

      if (priority) {
        deadlinesQuery = deadlinesQuery.eq('priority', priority)
      }

      const { data: deadlines, error: deadlinesError } = await deadlinesQuery

      if (deadlinesError) {
        console.error('[Admin Calendar API] Deadlines query error:', deadlinesError)
      } else {
        deadlines?.forEach((deadline: any) => {
          const color = getEventColor('deadline', deadline.priority)

          calendarEvents.push({
            id: `deadline-${deadline.id}`,
            title: `Deadline: ${deadline.title}`,
            type: 'deadline',
            start: new Date(deadline.created_at),
            end: new Date(deadline.created_at),
            color,
            description: deadline.content,
            status: 'upcoming',
            priority: deadline.priority || 'high',
            originalData: deadline
          })
        })
      }
    } catch (error) {
      console.error('[Admin Calendar API] Deadlines fetch error:', error)
    }

    // Add sample data for demonstration (only if no real data exists)
    if (calendarEvents.length === 0) {
      const sampleEvents = [
        {
          id: 'sample-1',
          title: 'Summer Music Festival',
          type: 'event',
          start: new Date(2024, 6, 15, 18, 0),
          end: new Date(2024, 6, 15, 23, 0),
          color: getEventColor('event', 'high'),
          location: 'Central Park, New York, NY',
          status: 'upcoming',
          priority: 'high'
        },
        {
          id: 'sample-2',
          title: 'Tour Planning Meeting',
          type: 'meeting',
          start: new Date(2024, 6, 10, 14, 0),
          end: new Date(2024, 6, 10, 15, 30),
          color: getEventColor('meeting', 'medium'),
          status: 'upcoming',
          priority: 'medium'
        },
        {
          id: 'sample-3',
          title: 'Venue Contract Deadline',
          type: 'deadline',
          start: new Date(2024, 6, 20, 17, 0),
          end: new Date(2024, 6, 20, 17, 0),
          color: getEventColor('deadline', 'urgent'),
          status: 'upcoming',
          priority: 'urgent'
        },
        {
          id: 'sample-4',
          title: 'Artist Booking Review',
          type: 'task',
          start: new Date(2024, 6, 12, 10, 0),
          end: new Date(2024, 6, 12, 11, 0),
          color: getEventColor('task', 'medium'),
          status: 'ongoing',
          priority: 'medium'
        },
        {
          id: 'sample-5',
          title: 'Equipment Setup',
          type: 'logistics',
          start: new Date(2024, 6, 14, 8, 0),
          end: new Date(2024, 6, 14, 12, 0),
          color: getEventColor('logistics', 'high'),
          status: 'upcoming',
          priority: 'high'
        },
        {
          id: 'sample-6',
          title: 'Sound Check',
          type: 'task',
          start: new Date(2024, 6, 15, 16, 0),
          end: new Date(2024, 6, 15, 17, 30),
          color: getEventColor('task', 'medium'),
          status: 'upcoming',
          priority: 'medium'
        },
        {
          id: 'sample-7',
          title: 'VIP Ticket Payment Due',
          type: 'payment',
          start: new Date(2024, 6, 18, 12, 0),
          end: new Date(2024, 6, 18, 12, 0),
          color: getEventColor('payment', 'high'),
          status: 'upcoming',
          priority: 'high'
        },
        {
          id: 'sample-8',
          title: 'Equipment Rental Booking',
          type: 'booking',
          start: new Date(2024, 6, 22, 9, 0),
          end: new Date(2024, 6, 22, 9, 0),
          color: getEventColor('booking', 'medium'),
          status: 'pending',
          priority: 'medium'
        }
      ]
      calendarEvents.push(...sampleEvents)
    }

    // Sort events by start date
    calendarEvents.sort((a, b) => new Date(a.start).getTime() - new Date(b.start).getTime())

    console.log(`[Admin Calendar API] Returning ${calendarEvents.length} events`)

    return NextResponse.json({
      success: true,
      events: calendarEvents,
      total: calendarEvents.length,
      filters: {
        startDate: defaultStartDate,
        endDate: defaultEndDate,
        eventType,
        status,
        priority
      },
      summary: {
        events: calendarEvents.filter(e => e.type === 'event').length,
        tours: calendarEvents.filter(e => e.type === 'tour').length,
        tasks: calendarEvents.filter(e => e.type === 'task').length,
        meetings: calendarEvents.filter(e => e.type === 'meeting').length,
        deadlines: calendarEvents.filter(e => e.type === 'deadline').length,
        bookings: calendarEvents.filter(e => e.type === 'booking').length,
        payments: calendarEvents.filter(e => e.type === 'payment').length,
        logistics: calendarEvents.filter(e => e.type === 'logistics').length
      }
    })

  } catch (error) {
    console.error('[Admin Calendar API] Error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    console.log('[Admin Calendar API] POST request started')
    
    const authResult = await authenticateApiRequest(request)
    if (!authResult) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { user, supabase } = authResult

    // Check admin permissions
    const hasAdminAccess = await checkAdminPermissions(user)
    if (!hasAdminAccess) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })
    }

    const body = await request.json()
    const { 
      title, 
      type, 
      start, 
      end, 
      description, 
      location, 
      priority,
      attendees = [],
      reminders = [],
      sendNotifications = false,
      enableReminders = false
    } = body

    // Validate required fields
    if (!title || !type || !start) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
    }

    let insertData: any = {
      created_by: user.id
    }

    let tableName = 'events'
    
    // Determine which table to insert into based on type
    switch (type) {
      case 'event':
        tableName = 'events'
        insertData = {
          ...insertData,
          name: title,
          description,
          event_date: new Date(start).toISOString().split('T')[0],
          event_time: new Date(start).toTimeString().split(' ')[0],
          status: 'scheduled',
          venue_name: location
        }
        break
      case 'tour':
        tableName = 'tours'
        insertData = {
          ...insertData,
          name: title,
          description,
          start_date: new Date(start).toISOString().split('T')[0],
          end_date: new Date(end || start).toISOString().split('T')[0],
          status: 'planning'
        }
        break
      case 'task':
        tableName = 'tasks'
        insertData = {
          ...insertData,
          title,
          description,
          due_date: new Date(start).toISOString(),
          status: 'todo',
          priority: priority || 'medium'
        }
        break
      case 'meeting':
        tableName = 'event_notes'
        insertData = {
          ...insertData,
          title,
          content: description,
          note_type: 'general',
          priority: priority || 'medium'
        }
        break
      case 'deadline':
        tableName = 'event_notes'
        insertData = {
          ...insertData,
          title,
          content: description,
          note_type: 'urgent',
          priority: priority || 'high'
        }
        break
      case 'booking':
        tableName = 'bookings'
        insertData = {
          ...insertData,
          status: 'pending',
          ticket_quantity: 1,
          total_price: 0
        }
        break
      case 'payment':
        tableName = 'event_expenses'
        insertData = {
          ...insertData,
          category: 'payment',
          description: title,
          amount: 0,
          expense_date: new Date(start).toISOString().split('T')[0],
          status: 'pending'
        }
        break
      case 'logistics':
        tableName = 'staff_schedules'
        insertData = {
          ...insertData,
          role: title,
          shift_start: new Date(start).toISOString(),
          shift_end: new Date(end || start).toISOString(),
          status: 'scheduled',
          notes: description
        }
        break
      default:
        return NextResponse.json({ error: 'Invalid event type' }, { status: 400 })
    }

    const { data, error } = await supabase
      .from(tableName)
      .insert(insertData)
      .select()
      .single()

    if (error) {
      console.error('[Admin Calendar API] Insert error:', error)
      return NextResponse.json({ error: 'Failed to create event' }, { status: 500 })
    }

    console.log('[Admin Calendar API] Event created successfully:', data)

    // Handle team member notifications if enabled
    if (sendNotifications && attendees.length > 0) {
      try {
        // Create notifications for team members
        const notificationPromises = attendees.map(async (attendeeId: string) => {
          // In a real app, you would fetch the attendee's email from the database
          // For now, we'll use mock data
          const attendeeEmails = {
            '1': 'alex@tourify.com',
            '2': 'sarah@tourify.com', 
            '3': 'michael@tourify.com',
            '4': 'emily@tourify.com'
          }
          
          const attendeeEmail = attendeeEmails[attendeeId as keyof typeof attendeeEmails]
          
          if (attendeeEmail) {
            // Create notification record
            await supabase
              .from('notifications')
              .insert({
                user_id: attendeeId, // In real app, this would be the actual user ID
                type: 'event_invitation',
                title: `New Event: ${title}`,
                content: `You have been invited to "${title}" on ${new Date(start).toLocaleDateString()} at ${new Date(start).toLocaleTimeString()}`,
                metadata: {
                  eventId: data.id,
                  eventType: type,
                  location,
                  description
                }
              })
            
            // Send email notification (in real app, this would use a service like Resend)
            console.log(`[Admin Calendar API] Would send email to ${attendeeEmail} about event: ${title}`)
          }
        })
        
        await Promise.all(notificationPromises)
        console.log('[Admin Calendar API] Team notifications sent successfully')
      } catch (notificationError) {
        console.error('[Admin Calendar API] Failed to send notifications:', notificationError)
        // Don't fail the entire request if notifications fail
      }
    }

    // Handle reminders if enabled
    if (enableReminders && reminders.length > 0) {
      try {
        // Create reminder records
        const reminderPromises = reminders.map(async (reminderTime: string) => {
          let reminderDate: Date
          
          // Calculate reminder time based on the reminder type
          switch (reminderTime) {
            case '5min':
              reminderDate = new Date(new Date(start).getTime() - 5 * 60 * 1000)
              break
            case '15min':
              reminderDate = new Date(new Date(start).getTime() - 15 * 60 * 1000)
              break
            case '30min':
              reminderDate = new Date(new Date(start).getTime() - 30 * 60 * 1000)
              break
            case '1hour':
              reminderDate = new Date(new Date(start).getTime() - 60 * 60 * 1000)
              break
            case '1day':
              reminderDate = new Date(new Date(start).getTime() - 24 * 60 * 60 * 1000)
              break
            case '1week':
              reminderDate = new Date(new Date(start).getTime() - 7 * 24 * 60 * 60 * 1000)
              break
            default:
              reminderDate = new Date(new Date(start).getTime() - 15 * 60 * 1000) // Default to 15 min
          }
          
          // Create reminder record
          await supabase
            .from('notifications')
            .insert({
              user_id: user.id,
              type: 'event_reminder',
              title: `Reminder: ${title}`,
              content: `Your event "${title}" is starting soon!`,
              metadata: {
                eventId: data.id,
                eventType: type,
                reminderTime,
                scheduledFor: reminderDate.toISOString()
              }
            })
        })
        
        await Promise.all(reminderPromises)
        console.log('[Admin Calendar API] Reminders created successfully')
      } catch (reminderError) {
        console.error('[Admin Calendar API] Failed to create reminders:', reminderError)
        // Don't fail the entire request if reminders fail
      }
    }

    const color = getEventColor(type, priority)

    return NextResponse.json({
      success: true,
      event: {
        id: `${type}-${data.id}`,
        title,
        type,
        start: new Date(start),
        end: new Date(end || start),
        color,
        description,
        location,
        priority,
        status: 'upcoming',
        attendees,
        reminders: enableReminders ? reminders : [],
        originalData: data
      }
    })

  } catch (error) {
    console.error('[Admin Calendar API] Error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
} 